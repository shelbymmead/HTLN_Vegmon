---
title: "Vegmon Script"
output:
  word_document: default
  html_document: default
author: Shelby Mead
date: "2024-12-17"
params: 
  park: HOSP # CHANGE THIS LINE to reflect park name
  class: !expr c(1:5) 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Code developed by Shelby Mead

# Setup
```{r}
##if you have never downloaded these packages, you must download by removing the # in next 4 lines:
#install.packages("tidyverse")
#install.packages("ggplot2")
#install.packages("purr")
#install.packages("boot")



#Otherwise, only these lines will run
library(tidyverse)
library(tidyr) # for crossing
library(purrr) # for iterating on bootstrap
library(boot) # for bootstrapping to get CIs


```

```{r}
parkcode <- params$park
class <- params$class


canopy <- read.csv(paste0("data/", parkcode, "canopy.csv"))
overstory <- read.csv(paste0("data/", parkcode, "overstory.csv"))
regeneration <- read.csv(paste0("data/", parkcode, "regeneration.csv")) 
species<- read.csv("data/tbl_Species_LU.csv")

overstory1 <- overstory |>
  filter(!is.na(DBH))|>
  mutate(class = as.character( # added this at the beginning
                 case_when(DBH < 15 ~ '1',
                           DBH >= 15 & DBH < 25 ~ '2',
                           DBH >= 25 & DBH < 35 ~ '3',
                           DBH >= 35 & DBH < 45 ~ '4',
                           DBH >= 45 ~ '5')), #makes class groupings
         site = as.character(Site))|> 
  filter(AcceptedSpecies != "Viburnum rufidulum") #filters out vibu rufi, no longer classified as overstory

reps = 250 # Number of bootstrap samples

#### Overstory ####
nsites_o <- overstory1 |>
  group_by(Year2) |>
  summarise(nsites = n_distinct(LocationID)) |>
  rename(Year = Year2)

year_o <- unique(na.omit(overstory1$Year2))

supplement_o <- overstory1 |>
  select(year = Year2, site) |>
  distinct() |>
  full_join((crossing(year_o, class)), by = c("year" = "year_o"), relationship = "many-to-many")|>
  arrange(year, site, class)

supplement_o[,c("site", "class")] <- sapply(supplement_o[,c("site", "class")], as.character) #setting site and class as characters
supplement_o <- tibble::as_tibble(supplement_o)
yxc_df <- unique(supplement_o[,c("year", "class")]) # need a dataframe with every comb. of Year and class
sxy_df <- unique(supplement_o[,c("year", "site")])

current_o <- max(year_o) #sets "current" as value representing most recent yr of sampling
first_o <- min(year_o) #sets "first" as value representing first yr of sampling

#### Canopy ####
nsites_c <- canopy |>
  group_by(Year) |>
  summarise(nsites = n_distinct(LocationID))

year_c <- unique(na.omit(canopy$Year))

#### Regeneration ####

nsites_r <- regeneration |>
  group_by(Year) |>
  summarise(nsites = n_distinct(LocationID))

year_r <- unique(na.omit(regeneration$Year))

current_r <- max(year_r) #sets "current" as value representing most recent yr of sampling
first_r <- min(year_r) #sets "first" as value representing first yr of sampling

theme_veg <- 
  function(){
  theme(axis.text.x = element_text(color = "grey20", size = 12, angle = 0, hjust = .5, vjust = .5, face = "plain",family     = "sans"),
        axis.text.y = element_text(color = "grey20", size = 12, angle = 0, hjust = 1, vjust = 0, face = "plain", family = "sans"),  
    axis.title.x = element_text(color = "grey20", size = 14, angle = 0, hjust = .5, vjust = 0, face = "plain", family
    = "sans"),
    axis.title.y = element_text(color = "grey20", size = 14, angle = 90, hjust = .5, vjust = .5, face = "plain", family = "sans"),
    legend.text = element_text(size = 12, hjust = .5, face = "plain",family = "sans"),
    legend.title = element_text(size = 14, face = "plain", family = "sans"),
    title = element_text(size = 14, face = "plain", family = "sans"),
    plot.margin = unit(c(0.5,0.5,0.5,0.5), 'cm'))} #this makes a text theme that can be used in all graphs (don't have to type out every time)

#--- Good to inspect the data some before analyzing it.---
# table(complete.cases(canopy)) # All complete; no NAs
# table(complete.cases(overstory)) # 1 NA that's completely blank upon inspection; removed in code above when I read in the csv.
# table(complete.cases(regeneration[,c("year", "LocationID", "AcceptedSpecies", "Origin", 
#                                      "SumOfSeedling", "SumOfSmallSapling", "SumOfLargeSapling", 
#                                      "GrowthHabit")])) # No NAs. 
# summary(canopy)
# summary(overstory)
# summary(regeneration)
#
# table(overstory$AcceptedSpecies, useNA = "always")
# # table(regeneration$AcceptedSpecies, useNA = 'always') 
# plot(overstory$DBH)
# plot(regeneration$SumOfSeedling) # Year 2007; HOSPVegMon1; Frangula caroliniana has a high, but believable count.
# plot(regeneration$SumOfSmallSapling) # Year 2007; HOSPVegMon1; Frangula caroliniana has a high, but believable count.
# 
# plot(canopy$SumOfValue.1)
# plot(canopy$SumOfValue.2)
# plot(canopy$SumOfValue.3)
# plot(canopy$SumOfValue.4)

```

# Basal Area

##Live
This chunk runs BA- live analysis

```{r}

ba_site_class1 <- overstory1 |>
  filter(Condition == "L") |> #sort live and dead
  mutate(ba_ha = DBH^2*(0.00007854)/0.1)|> #calculate basal area per ha
  group_by(Year2, site, class)|>
  summarise(ba_site = sum(ba_ha)) #calculate BA per site by class

ba_site_class2 <- left_join(supplement_o, ba_site_class1, by = c('year' = 'Year2','site', 'class')) #joining with supplement table to populate all combos for site, class
ba_site_class2$ba_site[is.na(ba_site_class2$ba_site)] <- 0
ba_site_class3 <- left_join(ba_site_class2, nsites_o, by = c("year" = "Year"))

if (min(nsites_o$nsites) >= 7 ) { #if sites are >= 7, the CI values will be bootstrapped

# Instead of assuming a normal distribution, I'm going to bootstrap the data to get a 
# sampling distribution of mean bas for each year x class combo

# Bootstrap function that will be used in purrr
boot_fun <- function(dat, col){
  dat1 <- dat[,col] # simplify dataframe into 1 column
  colnames(dat1) <- "col" # name column so easier to specify 
  samp <- dat1[sample(nrow(dat1), nrow(dat1), replace = T),] # sample the data once, returning same # rows with replacement
  mean <- mean(samp$col) # calculate mean of that sample
  return(data.frame(mean)) # return the mean as data.frame
}

# Iterate across year and class to get bootstrapped confidence intervals of ba

ba_year_class <- 
  purrr::map2(yxc_df$year, yxc_df$class, # iterate on each year x class combination 
              function(yr, cls){
                # create dataset for a given year x class combination
                dat <- ba_site_class2 |> filter(year == yr & class == cls)
                # create a data frame of bootstrapped means and bind list as rows in df
                dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "ba_site"), simplify = T)))
                # name the only column returned, so easier to specify below
                colnames(dat2) <- "samp_mean"
                # create a dataframe with mean of the raw data. 
                dat3 <- data.frame(ba_year_class = mean(dat$ba_site), # mean of raw data
                                   CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                   CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),# lower 95% of bootstrapped means
                                   year = yr,
                                   class = cls, 
                                   num_boots = reps)
            }) |> list_rbind() |> # bind output as rows of dataframe, instead of list
  select(year, class, ba_year_class, CI_low, CI_high, num_boots)

write.csv(ba_year_class, 'Tables/BasalAreaClass.csv', row.names = FALSE)

ba_year <-   purrr::map(year_o, # iterate on each year x class combination 
              function(yr){
                # create dataset for a given year x site combination
                dat <- ba_site_class2 |> filter(year == yr) |> group_by(site) |> summarize(ba_site = sum(ba_site))
                # create a data frame of bootstrapped means and bind list as rows in df
                dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "ba_site"), simplify = T)))
                # name the only column returned, so easier to specify below
                colnames(dat2) <- "samp_mean"
                # create a dataframe with mean of the raw data. 
                dat3 <- data.frame(ba_year = mean(dat$ba_site), # mean of raw data
                                   CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                   CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                   year = yr, 
                                   num_boots = reps)
            }) |> list_rbind() |> # bind output as rows of dataframe, instead of list
  select(year, ba_year, CI_low, CI_high, num_boots)

write.csv(ba_year, 'Tables/BasalArea.csv', row.names = FALSE)
} else{ #if sites are not >= 7, this code will run to calculate CI based on max and min values

ba_year_class <- ba_site_class3 |>
  group_by(year, class)|>
  reframe(ba_year_class = (sum(ba_site)/nsites),
            CI_low =  min(ba_site), #calculating low limit of Confidence interval
            CI_high = max(ba_site)) |>
  distinct()#calculating high limit of confidence interval
write.csv(ba_year_class, 'Tables/BasalAreaClass.csv', row.names = FALSE)


ba_year <- ba_site_class3 |>
  group_by(year, site, nsites) |>
  summarise(ba_site = sum(ba_site))|>
  group_by(year) |>
  reframe(ba_year = (sum(ba_site)/nsites),
            CI_low =  min(ba_site),#low limit of confidence interval
            CI_high = max(ba_site))|>
  distinct()#high limit of confidence interval
write.csv(ba_year, 'Tables/BasalArea.csv', row.names = FALSE)
}

```

This chunk creates BA-live graphs

```{r}

yearba <- 
  ggplot(ba_year, aes(x = year, y = ba_year)) +
  geom_line(linewidth = 0.75, color = 'gray30') +
  geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = 0.5, linewidth = 0.75, color = 'gray30') +
  geom_point(size = 4, color = 'gray30') + 
  labs(y = bquote('Mean Basal Area ' ~ (m^2/ha)),
       x = 'Year')+
  scale_y_continuous(expand = c(0,0), limits = c(0, 1.05*max(ba_year$CI_high)))+
  scale_x_continuous(breaks = scales::pretty_breaks(n=10))+
  theme_light()+
  theme_veg() 
yearba
ggsave('BasalArea.jpg', dpi = 600, path = "Graphs") #saves basal area graph to Output Graphs

ba_by_class <- 
  ggplot(ba_year_class, aes(x = class, y = ba_year_class, fill = factor(year))) +
    geom_col(position = 'dodge') + 
    geom_errorbar(aes(ymin = CI_low, ymax = CI_high), 
                  position = position_dodge(0.9), width = 0.2, linewidth = 0.2) +
    scale_y_continuous(expand = c(0,0), limits = c(0, 1.05*max(ba_year_class$CI_high)))+
    scale_fill_grey() +
    labs(y = bquote('Mean Basal Area ' ~ (m^2/ha)), fill = "Year",
         x = 'Class') + 
    theme_light()+
    theme_veg()  
  
ba_by_class
ggsave('BasalAreaClass.jpg', dpi = 600, path= "Graphs", height =5)#saves basal area by class graph to Output Graphs


```

## Dead

This chunk runs BA-dead analysis

```{r}
ba_site_class1_D <- overstory1 |>
  filter(Condition == "D" | Condition == "SD") |> #sort live and dead
  mutate(ba_ha = DBH^2*(0.00007854)/0.1)|> #calculate basal area per ha
  group_by(Year2, site, class)|>
  summarise(ba_site = sum(ba_ha)) #calculate BA per site by class

ba_site_class2_D <- left_join(supplement_o, ba_site_class1_D, by = c('year' = 'Year2', 'site', 'class')) #joining with supplement table to populate all combos for site, class
ba_site_class2_D$ba_site[is.na(ba_site_class2_D$ba_site)] <- 0
ba_site_class3_D <- left_join(ba_site_class2_D, nsites_o, by = c("year" = "Year"))

if (min(nsites_o$nsites) >= 7 ) { #if sites are >= 7, the CI values will be bootstrapped

# Instead of assuming a normal distribution, I'm going to bootstrap the data to get a 
# sampling distribution of mean bas for each year x class combo

# Iterate across year and class to get bootstrapped confidence intervals of ba

ba_year_class_D <- 
  purrr::map2(yxc_df$year, yxc_df$class, # iterate on each year x class combination 
              function(yr, cls){
                # create dataset for a given year x class combination
                dat <- ba_site_class2_D |> filter(year == yr & class == cls)
                # create a data frame of bootstrapped means and bind list as rows in df
                dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "ba_site"), simplify = T)))
                # name the only column returned, so easier to specify below
                colnames(dat2) <- "samp_mean"
                # create a dataframe with mean of the raw data. 
                dat3 <- data.frame(ba_year_class = mean(dat$ba_site), # mean of raw data
                                   CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                   CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),# lower 95% of bootstrapped means
                                   year = yr,
                                   class = cls, 
                                   num_boots = reps)
            }) |> list_rbind()|> # bind output as rows of dataframe, instead of list
  select(year, class, ba_year_class, CI_low, CI_high, num_boots)

write.csv(ba_year_class_D, 'Tables/BasalAreaClassD.csv', row.names = FALSE)

ba_year_D <-   purrr::map(year_o, # iterate on each year x class combination 
              function(yr){
                # create dataset for a given year x site combination
                dat <- ba_site_class2_D |> filter(year == yr) |> group_by(site) |> summarize(ba_site = sum(ba_site))
                # create a data frame of bootstrapped means and bind list as rows in df
                dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "ba_site"), simplify = T)))
                # name the only column returned, so easier to specify below
                colnames(dat2) <- "samp_mean"
                # create a dataframe with mean of the raw data. 
                dat3 <- data.frame(ba_year = mean(dat$ba_site), # mean of raw data
                                   CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                   CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                   year = yr, 
                                   num_boots = reps)
            }) |> list_rbind() |> # bind output as rows of dataframe, instead of list
  select(year, ba_year, CI_low, CI_high, num_boots)

write.csv(ba_year_D, 'Tables/BasalAreaD.csv', row.names = FALSE)
} else{ #if sites are not >= 7, this code will run to calculate CI based on max and min values

ba_year_class_D <- ba_site_class3_D |>
  group_by(year, class)|>
  reframe(ba_year_class = (sum(ba_site)/nsites),
            CI_low =  min(ba_site), #calculating low limit of Confidence interval
            CI_high = max(ba_site))|>
  distinct() #calculating high limit of confidence interval
write.csv(ba_year_class_D, 'Tables/BasalAreaClassD.csv', row.names = FALSE)


ba_year_D <- ba_site_class3_D |>
   group_by(year, site, nsites) |>
  summarise(ba_site = sum(ba_site))|>
  group_by(year) |>
  reframe(ba_year = (sum(ba_site)/nsites),
            CI_low =  min(ba_site),#low limit of confidence interval
            CI_high = max(ba_site))|>
  distinct()#high limit of confidence interval
write.csv(ba_year_D, 'Tables/BasalAreaD.csv', row.names = FALSE)
}
```

This chunk creates BA graphs for dead trees

```{r}

yearba_D <- 
  ggplot(ba_year_D, aes(x = year, y = ba_year)) +
  geom_line(linewidth = 0.75, color = 'gray30') +
  geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = 0.5, linewidth = 0.75, color = 'gray30') +
  geom_point(size = 4, color = 'gray30') + 
  labs(y = bquote('Mean Basal Area ' ~ (m^2/ha)),
       x = 'Year')+
  scale_y_continuous(expand = c(0,0), limits = c(0, 1.05*max(ba_year$CI_high)))+
  scale_x_continuous(breaks = scales::pretty_breaks(n=10))+
  theme_light()+
  theme_veg() 
yearba_D
ggsave('BasalAreaD.jpg', dpi = 600, path = "Graphs") #saves basal area graph to Output Graphs

ba_by_class_D <- 
  ggplot(ba_year_class_D, aes(x = class, y = ba_year_class, fill = factor(year))) +
    geom_col(position = 'dodge') + 
    geom_errorbar(aes(ymin = CI_low, ymax = CI_high), 
                  position = position_dodge(0.9), width = 0.2, linewidth = 0.2) +
    scale_y_continuous(expand = c(0,0), limits = c(0, 1.05*max(ba_year_class$CI_high)))+
    scale_fill_grey() +
     labs(y = bquote('Mean Basal Area ' ~ (m^2/ha)), fill = "Year",
         x = 'Class') +
    theme_light()+
    theme_veg()  
  
ba_by_class_D
ggsave('BasalAreaClassD.jpg', dpi = 600, path= "Graphs", height =5)#saves basal area by class graph to Output Graphs

```

# Density

## Live

This chunk runs the density analysis

```{r}

density <- overstory1 |>
  filter(Condition == 'L', SpeciesCode != "SNAG")|> #filters out dead trees and snags
  group_by(year = Year2, site, class)|> # note how you can rename things in a group_by. 
  summarise(count = n(), .groups = 'drop') #count number of stems in each density class for each year, site

density1 <- left_join(supplement_o, density, by = c("year", "site", "class"))
density1$count[is.na(density1$count)] <- 0
density1$areadensity = density1$count/0.1
density2 <- left_join(density1, nsites_o,by = c("year" = "Year"))

 # Iterate across year and class to get bootstrapped confidence intervals of ba
if (min(nsites_o$nsites) >= 7 ) { #this runs if sites are >7
density_year_class <- 
  purrr::map2(yxc_df$year, yxc_df$class, # iterate on each year x class combination 
              function(yr, cls){
                # create dataset for a given year x class combination
                dat <- density1 |> filter(year == yr & class == cls)
                # create a data frame of bootstrapped means and bind list as rows in df
                dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "areadensity"), simplify = T)))
                # name the only column returned, so easier to specify below
                colnames(dat2) <- "samp_mean"
                # create a dataframe with mean of the raw data. 
                dat3 <- data.frame(dens_year_class = mean(dat$areadensity), # mean of raw data
                                   CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                   CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                   year = yr,
                                   class = cls, 
                                   num_boots = reps)
              }) |> list_rbind() |> # bind output as rows of dataframe, instead of list
  select(year, class, dens_year_class, CI_low, CI_high, num_boots)

write.csv(density_year_class, 'Tables/DensityClass.csv', row.names = FALSE)
density_year_class

density_year <-   purrr::map(year_o, # iterate on each year x class combination 
                        function(yr){
                          # create dataset for a given year x site combination
                          dat <- density1 |> filter(year == yr) |> group_by(site) |> summarize(areadensity = sum(areadensity))
                          # create a data frame of bootstrapped means and bind list as rows in df
                          dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "areadensity"), simplify = T)))
                          # name the only column returned, so easier to specify below
                          colnames(dat2) <- "samp_mean"
                          # create a dataframe with mean of the raw data. 
                          dat3 <- data.frame(dens_year = mean(dat$areadensity), # mean of raw data
                                             CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                             CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                             year = yr, 
                                             num_boots = reps)
                        }) |> list_rbind() |> # bind output as rows of dataframe, instead of list
  select(year, dens_year, CI_low, CI_high, num_boots)

write.csv(density_year, 'Tables/Density.csv', row.names = FALSE)
density_year
} else { #this runs if sites < 7

  
density_year_class <- density2 |>
  group_by(year, class)|>
  reframe(dens_year_class = (sum(areadensity)/nsites),
            CI_low =  min(areadensity), #calculating low limit of Confidence interval
            CI_high = max(areadensity)) |>
  distinct()#calculating high limit of confidence interval
write.csv(density_year_class, 'Tables/DensityClass.csv', row.names = FALSE)
density_year_class


density_year <- density2 |>
  group_by(year, site, nsites) |>
  summarise(SiteDensity = sum(areadensity))|>
  group_by(year) |>
  reframe(dens_year = (sum(SiteDensity)/nsites),
            CI_low =  min(SiteDensity),#low limit of confidence interval
            CI_high = max(SiteDensity))|>
  distinct()#high limit of confidence interval
write.csv(density_year, 'Tables/Density.csv', row.names = FALSE)
density_year

}
```

This chunk makes density graphs

```{r}

yeardensity <- 
  ggplot(density_year, aes(x = year, y = dens_year)) +
  geom_line(linewidth = 0.75, color = 'gray30') +
  geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = 0.5, linewidth = 0.75, color = 'gray30') +
  geom_point(size = 4, color = 'gray30') + 
  labs(y = 'Mean Stem Density (stem/ha)',
       x = 'Year')+
  scale_y_continuous(expand = c(0,0), limits = c(0, 1.05*max(density_year$CI_high)))+
  scale_x_continuous(breaks = scales::pretty_breaks(n=10))+
  theme_light()+
  theme_veg()
  
yeardensity
ggsave('Density.jpg', dpi = 600, path = "Graphs") #saves density graph to Output Graphs

class_density <- 
  ggplot(density_year_class, aes(x = class, y = dens_year_class, fill = factor(year))) +
    geom_col(position = 'dodge') + 
    geom_errorbar(aes(ymin = CI_low, ymax = CI_high), 
                  position = position_dodge(0.9), width = 0.2, linewidth = 0.2) +
    scale_y_continuous(expand = c(0,0), limits = c(0, 1.05*max(density_year_class$CI_high)))+
    scale_fill_grey() +
    labs(y = 'Mean Stem Density (stem/ha)', fill = "Year",
         x = 'Class') + 
    theme_light()+
    theme_veg()  
  
class_density
ggsave('DensityClass.jpg', dpi = 600, path= "Graphs", height =5)#saves basal area by class graph to Output Graphs

```


## Dead

This chunk runs the density analysis for dead trees

```{r}
density_D <- overstory1 |>
 filter(Condition == "D" | Condition == "SD") |> #sort live and dead   # note how you can rename things in a group_by. 
   group_by(year = Year2, site, class)|>
  summarise(count = n(), .groups = 'drop') #count number of stems in each density class for each year, site

density1_D <- left_join(supplement_o, density_D, by = c("year", "site", "class"))
density1_D$count[is.na(density1_D$count)] <- 0
density1_D$areadensity = density1_D$count/0.1
density2_D <- left_join(density1_D, nsites_o,by= c("year" = "Year"))

 # Iterate across year and class to get bootstrapped confidence intervals of ba
if (min(nsites_o$nsites) >= 7 ) { #this runs if sites are >7
density_year_class_D <- 
  purrr::map2(yxc_df$year, yxc_df$class, # iterate on each year x class combination 
              function(yr, cls){
                # create dataset for a given year x class combination
                dat <- density1_D |> filter(year == yr & class == cls)
                # create a data frame of bootstrapped means and bind list as rows in df
                dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "areadensity"), simplify = T)))
                # name the only column returned, so easier to specify below
                colnames(dat2) <- "samp_mean"
                # create a dataframe with mean of the raw data. 
                dat3 <- data.frame(dens_year_class = mean(dat$areadensity), # mean of raw data
                                   CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                   CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                   year = yr,
                                   class = cls, 
                                   num_boots = reps)
              }) |> list_rbind() |> # bind output as rows of dataframe, instead of list
  select(year, class, dens_year_class, CI_low, CI_high, num_boots)

write.csv(density_year_class_D, 'Tables/DensityClass_D.csv', row.names = FALSE)
density_year_class_D

density_year_D <-   purrr::map(year_o, # iterate on each year x class combination 
                        function(yr){
                          # create dataset for a given year x site combination
                          dat <- density1_D |> filter(year == yr) |> group_by(site) |> summarize(areadensity = sum(areadensity))
                          # create a data frame of bootstrapped means and bind list as rows in df
                          dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "areadensity"), simplify = T)))
                          # name the only column returned, so easier to specify below
                          colnames(dat2) <- "samp_mean"
                          # create a dataframe with mean of the raw data. 
                          dat3 <- data.frame(dens_year = mean(dat$areadensity), # mean of raw data
                                             CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                             CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                             year = yr, 
                                             num_boots = reps)
                        }) |> list_rbind() |> # bind output as rows of dataframe, instead of list
  select(year, dens_year, CI_low, CI_high, num_boots)

write.csv(density_year_D, 'Tables/Density_D.csv', row.names = FALSE)
density_year_D
} else { #this runs if sites < 7

  
density_year_class_D <- density2_D |>
  group_by(year, class)|>
  reframe(dens_year_class = (sum(areadensity)/nsites),
            CI_low =  min(areadensity), #calculating low limit of Confidence interval
            CI_high = max(areadensity)) |>
  distinct()#calculating high limit of confidence interval
write.csv(density_year_class_D, 'Tables/DensityClass_D.csv', row.names = FALSE)
density_year_class_D


density_year_D <- density2_D |>
  group_by(year, site, nsites) |>
  summarise(SiteDensity = sum(areadensity))|>
  group_by(year) |>
  reframe(dens_year = (sum(SiteDensity)/nsites),
            CI_low =  min(SiteDensity),#low limit of confidence interval
            CI_high = max(SiteDensity))|>
  distinct()#high limit of confidence interval
write.csv(density_year_D, 'Tables/Density_D.csv', row.names = FALSE)
density_year_D

}
```

This chunk makes density graphs for dead trees

```{r}
yeardensity_D <- 
  ggplot(density_year_D, aes(x = year, y = dens_year)) +
  geom_line(linewidth = 0.75, color = 'gray30') +
  geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = 0.5, linewidth = 0.75, color = 'gray30') +
  geom_point(size = 4, color = 'gray30') + 
  labs(y = 'Mean Stem Density (stem/ha)',
       x = 'Year')+
  scale_y_continuous(expand = c(0,0), limits = c(0, 1.05*max(density_year$CI_high)))+ #leave as alive y-axis bounds to make graphs comprable
  scale_x_continuous(breaks = scales::pretty_breaks(n=10))+
  theme_light()+
  theme_veg()
  
yeardensity_D
ggsave('DensityD.jpg', dpi = 600, path = "Graphs") #saves density graph to Output Graphs

class_density_D <- 
  ggplot(density_year_class_D, aes(x = class, y = dens_year_class, fill = factor(year))) +
    geom_col(position = 'dodge') + 
    geom_errorbar(aes(ymin = CI_low, ymax = CI_high), 
                  position = position_dodge(0.9), width = 0.2, linewidth = 0.2) +
    scale_y_continuous(expand = c(0,0), limits = c(0, 1.05*max(density_year_class$CI_high)))+#leave as alive y-axis bounds to make graphs comprable
    scale_fill_grey() +
    labs(y = 'Mean Stem Density (stem/ha)', fill = "Year",
         x = 'Class') + 
    theme_light()+
    theme_veg()  
  
class_density_D
ggsave('DensityClassD.jpg', dpi = 600, path= "Graphs", height =5)#saves basal area by class graph to Output Graphs

```

#Species-Wise Analysis

## Live

```{r}
## Calculating species change by BA
species_ba_site <- overstory1 |>
  filter(Condition == "L")|> #filter for only Live trees
  mutate(ba_ha = DBH^2*(0.00007854/0.1)) |> #convert DBH to BA scaled to hectare
  group_by(year = Year2, site, AcceptedSpecies)|>
 summarise(ba_site = sum(ba_ha, na.rm = T), .groups = 'drop') #summarise total BA of site
  
species_ba_site <- left_join(species_ba_site, nsites_o, by = c("year" = "Year"))

species_ba <- species_ba_site |> 
  group_by(year, AcceptedSpecies)|> 
  reframe(meanba = sum(ba_site, na.rm = T)/nsites)|>  #calculate mean ba_site for entire year
  distinct()

pivotspecies_ba <- species_ba |> pivot_wider(names_from = year, values_from = meanba, values_fill = 0) |> #make into pivot table for more accessible export
  arrange(AcceptedSpecies) |> data.frame()

current_col <- which(grepl(current_o, names(pivotspecies_ba))) # Find column that matches current year
first_col <- which(grepl(first_o, names(pivotspecies_ba))) # Find column that matches first year

pivotspecies_ba$change <- pivotspecies_ba[,current_col] - pivotspecies_ba[,first_col] # Calc change between first year and most current year

pivotspecies_ba$direction <- ifelse(pivotspecies_ba$change > 0, "Increase", "Decrease") #designation direction of change for graphs

write.csv(pivotspecies_ba, "Tables/SpeciesBA.csv", row.names = FALSE)
pivotspecies_ba  


## Calculating species change by Density

species_density_site <- overstory1 |>
  filter(Condition == "L")|> #filter for only living trees
  group_by(year = Year2, site, AcceptedSpecies)|>
  summarise(stem_ha = sum(!is.na(DBH))/0.1, .groups = 'drop') #calculates total density of site

species_density_site <- left_join(species_density_site, nsites_o, by = c("year" = "Year"))

species_density <- species_density_site |>
  group_by(year, AcceptedSpecies)|>
  reframe(meandensity = sum(stem_ha)/nsites) |> #calculates year mean density for each species
  distinct()

pivotspecies_density <- species_density |> pivot_wider(names_from = year, values_from = meandensity, values_fill = 0) |> #make into pivot table for more accessible export
  arrange(AcceptedSpecies) |> data.frame()

current_col <- which(grepl(current_o,names(pivotspecies_density))) # Find column that matches current year
first_col <- which(grepl(first_o, names(pivotspecies_density))) # Find column that matches first year

pivotspecies_density$change <- pivotspecies_density[,current_col] - pivotspecies_density[,first_col] # Calc. change

pivotspecies_density$direction <- ifelse(pivotspecies_density$change > 0, "Increase", "Decrease")

write.csv(pivotspecies_density, 'Tables/SpeciesDensity.csv', row.names=FALSE)
pivotspecies_density
```

## Occurrence table
```{r}

pct_occ1 <- overstory1 |>
  group_by(Year2, site, AcceptedSpecies) |> 
  summarize(present = ifelse(sum(!is.na(DBH)) > 0, 1, 0), .groups = 'drop')|>
  left_join(nsites_o, by = c("Year2" = "Year"))

pct_occ2 <- pct_occ1 |>
  group_by(Year2, AcceptedSpecies) |>
  reframe(percentoccurrence = sum(present)/nsites*100)|>
  filter(Year2 == current_o) |>
  select(AcceptedSpecies, percentoccurrence) |>
  distinct()

acc_spp <- data.frame(AcceptedSpecies = sort(unique(overstory1$AcceptedSpecies)))

pct_occ <- right_join(pct_occ2, acc_spp, by = "AcceptedSpecies") |> 
  mutate(percentoccurrence = ifelse(is.na(percentoccurrence), 0, percentoccurrence)) |> 
  arrange(AcceptedSpecies) |>
  left_join(species, by = "AcceptedSpecies") |>
  select(AcceptedSpecies, USDA_CName, percentoccurrence)
  
write.csv(pct_occ, "Tables/PercentOccurrence.csv", row.names = F)

```

This chunk creates change charts by species name

```{r}
## Subtraction change in BA
ggplot(pivotspecies_ba, 
       aes(y = reorder(AcceptedSpecies, desc(AcceptedSpecies)), 
           x = change, fill = factor(direction)))+ # sets ggplot to show species change in density
  geom_col(width = 0.4)+ #makes the ggplot a barplot
  theme_light()+ #background theme
  labs(y = 'Species Name', x = 'Change in Mean Basal Area', fill = "Direction")+ #x axis label
  scale_fill_manual(breaks = c('Decrease', 'Increase'),
                    values = c('#FDB338', '#025196'))+ #manually setting color scale
  scale_x_continuous(breaks = scales::pretty_breaks(n=12))+
  theme_veg() +
  theme(axis.text.y = element_text(face = "italic"), axis.text.x = element_text(angle = 90))+
  geom_vline(xintercept = 0)
ggsave('SpBAchange.jpg', dpi = 600, height = 8, width = 8, path = "Graphs")

## subtraction change in Density
ggplot(pivotspecies_density, 
       aes(y = reorder(AcceptedSpecies, desc(AcceptedSpecies)), 
           x = change, fill = factor(direction)))+ # sets ggplot to show species change in density
  geom_col(width = 0.4)+ #makes the ggplot a barplot
  theme_light()+ #background theme
  labs(y = 'Species Name', x = 'Change in Mean Density (stems/ha)', fill = "Direction")+ #x axis label
  scale_fill_manual(breaks = c('Decrease', 'Increase'),
                    values = c('#FDB338', '#025196'))+ #manually setting color scale
  scale_x_continuous(breaks = scales::pretty_breaks(n=12))+
  theme_veg() +
  theme(axis.text.y = element_text(face = "italic"), axis.text.x = element_text(angle = 90))+
  geom_vline(xintercept = 0)
ggsave('SpDensitychange.jpg', dpi = 600, height = 8, width = 8, path = "Graphs")
```

# Canopy

This chunk of code makes table

```{r}

sum_cols <- c("SumOfValue.1", "SumOfValue.2", "SumOfValue.3", "SumOfValue.4")
canopy1 <- canopy
canopy1$site = as.character(gsub("[[:alpha:]]", "", canopy1$LocationID)) # Extract site number using base R
canopy1[, sum_cols][canopy1[,sum_cols] < 0] <- NA #if any values <0 converts to NA

canopy2 <- canopy1 |>
  mutate(C1 = SumOfValue.1 * 1.04, C2 = SumOfValue.2 * 1.04, C3 = SumOfValue.3 * 1.04, C4 = SumOfValue.4 * 1.04) |> #multiply by 1.04
  mutate(plotmean = (C1+C2+C3+C4)/4) |> data.frame()#|> #Calculate Plot mean (n=4)

sxy_df2 <- canopy2 |> select(year = Year, site) |> unique()

canopy_site <- canopy2 |>
  group_by(Year, site) |>
  rename(year = Year) |>
  summarize(sitemean = mean(plotmean)) #calculate mean for each site

canopy_site2 <- left_join(canopy_site, nsites_c, by = c("year" = "Year"))
  
 
if (min(nsites_c$nsites) >= 7 ) {
# Bootstrap function that will be used in purrr
boot_fxn <- function(dat, col){
  dat1 <- data.frame(dat[,col]) # simplify dataframe into 1 column; not sure why I had to do this different than prev. boot_fun
  samp <- data.frame(dat1[sample(nrow(dat1), nrow(dat1), replace = T),]) # sample the data once, returning same # rows with replacement
  colnames(samp) <- "col" # name column so easier to specify 
  mean <- mean(samp$col) # calculate mean of that sample
  return(data.frame(mean)) # return the mean as data.frame
}

canopy_year <- 
  purrr::map(year_c, function(yr){
                          dat <- canopy_site |> filter(year == yr) 
                          dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fxn(dat, "sitemean"), simplify = T)))
                          colnames(dat2) <- "samp_mean"
                          dat3 <- data.frame(yearmean = mean(dat$sitemean), # mean of raw data
                                             CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                             CI_low= quantile(dat2$samp_mean, probs = 0.025, names = F),
                                             year = yr, 
                                             num_boots = reps)
                        }) |> list_rbind() |>
  select(year, yearmean, CI_low, CI_high, num_boots)
write.csv(canopy_year, 'Tables/canopyMean.csv', row.names = FALSE)
} else {
  
  canopy_year <- canopy_site2 |>
  group_by(year) |>
  reframe(yearmean = (sum(sitemean)/nsites),
             CI_low= min(sitemean),#Calculate higher limit of 95% Confidence Interval
             CI_high= max(sitemean)) |> #calculate lower limit of confidence interval
  distinct()
write.csv(canopy_year, 'Tables/canopyMean.csv', row.names = FALSE)
}

```

This chunk of code makes canopy graph

```{r}

mean_canopy <- 
  ggplot(canopy_year, aes(x = year, y = yearmean)) +
    geom_line(linewidth = 0.75, color = 'gray30') +
    geom_errorbar(aes(x = year, ymin = CI_low, ymax = CI_high), width = 0.5, linewidth = 0.75, color = 'gray30') +
    geom_point(size = 4, color = 'gray30') + 
    scale_y_continuous(expand = c(0,0), limits = c(0, 1.05*max(canopy_year$CI_high)))+
    scale_x_continuous(breaks = scales::pretty_breaks(n=10))+
    labs(y = 'Mean Canopy Cover (%)', x = 'Year')+
    theme_light()+
    theme_veg() 
    
mean_canopy
ggsave("CanopyMean.jpg", dpi = 600, path = "Graphs", height = 4)


Canopy_by_site<- ggplot(canopy_site, aes(x = site, y =sitemean, fill=factor(year)))+ # makes ggplot of canopy with color indicating site
  geom_col(position = 'dodge')+
   scale_fill_grey()+
  labs(y = 'Mean Canopy Cover (%)', x = 'Site', fill = "Year")+
  scale_y_continuous(expand = c(0,0), limits = c(0, 1.05*max(canopy_site$sitemean)))+
  theme_light()+
  theme_veg()

Canopy_by_site
ggsave("CanopySite.jpg", dpi = 600, path = "Graphs", height = 4)
```


# Regeneration

This chunk of code calculates regeneration density by  Class

```{r}
regeneration1 <- regeneration
names(regeneration1) <- gsub("SumOf", "", names(regeneration1)) # Drop SumOf from column names
regeneration1$site = as.character(gsub("[[:alpha:]]", "", regeneration1$LocationID)) # Extract site number using base R

type_regen1 <- 
  regeneration1 |> select(year = Year, site, AcceptedSpecies, Seedling, SmallSapling, LargeSapling) |> #selecting columns
  pivot_longer(cols = c(Seedling, SmallSapling, LargeSapling), names_to = "class", values_to = "count") |> #making single row for each class
  group_by(year, site, class) |> 
  summarize(sum1 = sum(count), 
            sum_ha = sum1/0.01,
            .groups = 'drop') 

type_regen2 <- left_join(type_regen1, nsites_r, by = c("year" = "Year"))

if (min(nsites_r$nsites) >= 7){
yxc_df2 <- type_regen1 |> select(year, class) |> unique() |> data.frame()

type_regen <-
  purrr::map2(yxc_df2$year, yxc_df2$class, function(yr, cls){
    dat <- type_regen1 |> filter(year == yr & class == cls)
    dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fxn(dat, "sum_ha"), simplify = T)))
    colnames(dat2) <- "samp_mean"
    dat3 <- data.frame(year = yr,
                       class = cls,
                       meandensity = mean(dat$sum_ha), # mean of raw data
                       CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                       CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                       num_boots = reps)
    }) |> list_rbind()|>
          mutate(class = ifelse(class == "LargeSapling", "Large Sapling", ifelse(class == "SmallSapling", "Small Sapling", "Seedling")))


write.csv(type_regen, "Tables/RegenType.csv")
type_regen
} else{

type_regen <- type_regen2 |>
  group_by(year, class)|> 
  reframe(meandensity = (sum(sum_ha)/nsites),#calculate mean density
            CI_low = min(sum_ha), #calculate low end of 95 conf interval
            CI_high = max(sum_ha)) |> #calculate low end of 95 conf interval
  distinct() |>
  mutate(class = ifelse(class == "LargeSapling", "Large Sapling", ifelse(class == "SmallSapling", "Small Sapling", "Seedling")))

write.csv(type_regen, "Tables/RegenType.csv", row.names = FALSE)
type_regen
}

```

This chunk makes a graph of regeneration density by class 

```{r}
type_regen$class <- factor(type_regen$class, levels = c("Seedling", "Small Sapling", "Large Sapling"))

type_regen_graph <-
  ggplot(type_regen |> arrange(meandensity), aes(x = class, y = meandensity, fill = factor(year)))+
  scale_fill_grey()+
  geom_col(position = "dodge")+ #sets bars next to each other
  geom_errorbar(aes(x = class, ymin = CI_low, ymax= CI_high), width = 0.2, position = position_dodge(0.9), linewidth = 0.2)+ #add error bar
  labs(y = 'Mean Density (stems/ha)', fill = "Year", x = "Class")+
  scale_y_continuous(expand = c(0,0), limits = c(0, 1.05*max(type_regen$CI_high)))+
  theme_light()+
  theme_veg()

type_regen_graph
ggsave('RegenType.jpg', path = "Graphs", dpi= 600)
  
```

## Regen by species

```{r}

#this creates the dataframe used to generate graphs

regen_species1 <- regeneration1 |>
  select(year = Year, site, AcceptedSpecies, Seedling, SmallSapling, LargeSapling) |>
  pivot_longer(cols = c(Seedling, SmallSapling, LargeSapling), names_to = "class", values_to = "count")|> #making each class its own row
  mutate(density_ha = count/0.01)|> #convert density to ha
  select(!count)|>
  left_join(nsites_r, by = c("year" = "Year"))|>
  group_by(year, AcceptedSpecies, class)|> #sort by species each year
  reframe(year_density = (sum(density_ha)/nsites)) |> #summarise the year mean density class 
  distinct()|>
  arrange(desc(AcceptedSpecies), factor(class, c("Seedling", "SmallSapling", "LargeSapling")))


regen_species_curr <- regen_species1 |> filter(year == current_r)
regen_species_first <- regen_species1 |> filter(year == first_r)

regen_species2 <- full_join(regen_species_curr |> select(-year), #select current year data but not the "year" column"" column
                          regen_species_first |> select(-year), #select first year data but not the "year" column"" column
                          by = c("AcceptedSpecies", "class"),
                          suffix = c("_curr", "_first")) |> 
  mutate(year_density_curr = ifelse(is.na(year_density_curr), 0, year_density_curr),#set NA to 0
         year_density_first = ifelse(is.na(year_density_first), 0, year_density_first),#set NA to 0
         change = year_density_curr - year_density_first,
         direction = case_when(change > 0 ~ "Increase", #assign directional value
                               change < 0 ~ "Decrease", #assign directional value
                               change == 0 ~ "No change")) |> #assign directional value
  arrange(AcceptedSpecies) |>
  select(AcceptedSpecies, class, change, direction)
  
regen_species <- regen_species2 |>
  right_join(regen_species1, by = c("AcceptedSpecies", "class")) |> #join to regenspecies to show all values of all years
  group_by(AcceptedSpecies, class) |>
  mutate(check = sum(year_density)) |> #making a check to remove any values where there were NEVER species in a certain class, helps graphs
  filter(check != 0) |>
  select(-c(check, year, year_density))|> #remove extra check column, year, and year density
  distinct() #remove duplicate rows
  

#table(regenSpecies_comb$AcceptedSpecies, regenSpecies_comb$class) # make sure every species/class is represented only once

#this creates the wider dataframe to export
class_changes <- regen_species |>
  select(-direction)|>
  pivot_wider(names_from = class, values_from = change)|> #making the table wider so each class is a column in a single row
  rename(change_seedling = Seedling,
         change_smallsapling = SmallSapling,
         change_largesapling = LargeSapling)


# Set order of factor levels for class
regen_species1$class <- factor(regen_species1$class, levels = c("Seedling", "SmallSapling", "LargeSapling"))

regen_species_table <- regen_species1 |>
  arrange(class) |> 
  pivot_wider(names_from = c(class, year), values_from = year_density)|>
  arrange(AcceptedSpecies)|>
  left_join(class_changes, by = "AcceptedSpecies")

  
write.csv(regen_species_table, "Tables/RegenSpecies.csv", row.names = F)

regen_species_table
  
  
```

This chunk makes change graphs for regeneration by species, each class is graphed alone
```{r}


## Seedling
seedling <-
  ggplot(regen_species |> filter(class == "Seedling"), 
         aes(y = reorder(AcceptedSpecies, desc(AcceptedSpecies)), 
             x = change, fill = direction))+ #ggplot y axis barplot with colors based on increase or decrease
  geom_col(width = 0.4)+ #width of columns
  theme_light()+
  xlab('Change in Mean Density (stems/ha)')+
  ylab('Species Name')+
  labs(title = 'Seedlings', fill = "Direction")+
  scale_fill_manual(breaks = c(breaks = c('Decrease','Increase', 'No change')),
                    values = c('#FDB338', '#025196', 'dimgrey'))+#sets color for increase/decrease
  scale_x_continuous(breaks = scales::pretty_breaks(n=15))+ #changes number of ticks on x axis
  theme_veg()+
  theme(axis.text.y = element_text(face = "italic"), #makes species names italic
        axis.text.x = element_text(angle = 90))+
  geom_vline(xintercept = 0)
seedling
ggsave('RegenSpSeedling.jpg', path = "Graphs", dpi= 600, height = 8)
  
## Small Sapling
smallsapling <- 
  ggplot(regen_species |> filter(class == "SmallSapling"), 
         aes(y = reorder(AcceptedSpecies, desc(AcceptedSpecies)), 
             x = change, fill = direction))+#ggplot y axis barplot with colors based on increase or decrease
  geom_col(width = 0.4)+#width of columns
 theme_light()+
  xlab('Change in Mean Density (stems/ha)')+
  ylab('Species Name')+
  labs(title = 'Small Saplings', fill = "Direction")+
  scale_fill_manual(breaks = c('Decrease','Increase', 'No change'),
                    values = c('#FDB338', '#025196', 'dimgrey'))+#sets color for increase/decrease
  scale_x_continuous(breaks = scales::pretty_breaks(n=15))+#changes number of ticks on x axis
  theme_veg()+
  theme(axis.text.y = element_text(face = "italic"),#makes species names italic
        axis.text.x = element_text(angle = 90))+
  geom_vline(xintercept = 0)
smallsapling
ggsave('RegenSpSmallSap.jpg', path = "Graphs", dpi= 600, height = 6)

## Large Sapling
largesapling <- 
  ggplot(regen_species |> filter(class == 'LargeSapling'), #filter for large saplings
         aes(y = reorder(AcceptedSpecies, desc(AcceptedSpecies)), 
             x = change, fill = direction)) + #ggplot y axis barplot with colors based on increase or decrease
  geom_col(width = 0.4)+ #width of columns
  theme_light()+
  xlab('Change in Mean Density (stems/ha)')+
  ylab('Species Name')+
  labs(title = 'Large Saplings', fill = "Direction")+
  scale_fill_manual(breaks = c(breaks = c('Decrease','Increase', 'No change')),
                    values = c('#FDB338', '#025196', 'dimgrey'))+#sets color for increase/decrease
  theme_veg()+
  theme(axis.text.y = element_text(face = "italic"))+#makes species names italic
  geom_vline(xintercept = 0)
largesapling
ggsave('RegenSpLargeSap.jpg', path = "Graphs", dpi=600, height = 6)

```
