---
# This section is called the YAML heading
title: "Vegmon Script"
output:
  word_document: default
  html_document: default
author: Shelby Mead
date: "2024-12-17"
params: 
  park: HOSP
  Year: 2024
  sites: !expr c(1:7) # !expr makes sure sites is a vector
  class: !expr c(1:5) # !expr makes sure class is a vector
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load libraries
##if you have never downloaded these packages, you must download by removing the # in following line:
#install.packages("tidyverse") # ggplot2, dplyr and stringr install with the tidyverse bundle. No need to install separately.
library(ggplot2) 
library(dplyr) 
library(stringr)
library(tidyr) # for crossing
library(purrr) # for iterating on bootstrap
#library(boot) # for bootstrapping to get CIs
```

```{r}
# Read in data and set constants from params
parkcode <- params$park
site <- params$sites
class <- params$class

# Uncomment to define params when troubleshooting within doc
# parkcode <- "HOSP" ; Year <- 2024 ; site <- 1:7 ; class <- 1:5

canopy <- read.csv(paste0("data/", parkcode, "canopy.csv")) #KMM: I changed the file name to be more general
overstory <- read.csv(paste0("data/", parkcode, "overstory.csv")) |> filter(!is.na(DBH)) #KMM: I changed the file name to be more general
regeneration <- read.csv(paste0("data/", parkcode, "regeneration.csv")) #KMM: I changed the file name to be more general

overstory1 <- overstory |>
  mutate(class = as.character( # added this at the beginning
                 case_when(DBH < 15 ~ '1',
                           DBH >= 15 & DBH < 25 ~ '2',
                           DBH >= 25 & DBH < 35 ~ '3',
                           DBH >= 35 & DBH < 45 ~ '4',
                           DBH >= 45 ~ '5')), #makes class groupings
         site = as.character(Site))|> 
  #mutate(Year2 = as.character(Year2))|> # KMM: Am checking whether this is necessary
 filter(AcceptedSpecies != "Viburnum rufidulum") #filters out vibu rufi, no longer classified as overstory

year <- unique(na.omit(overstory1$Year2))
supplement <- crossing(year, site, class) #creates dataframe so all combos of year, site, and class can have a zero value
supplement[,c("site", "class")] <- sapply(supplement[,c("site", "class")], as.character) # Doing this earlier instead of in a pipe later

current <- max(year)
first <- min(year)

nsites <- length(unique(canopy$LocationID))  #sets 'n' as number of sites, if not all sites are measured in all years just enter site number manually 

theme_veg <- #KMM: Note that I changed the theme name and turned it into a function, so more stable.
  function(){
  theme(axis.text.x = element_text(color = "grey20", size = 10, angle = 0, hjust = .5, vjust = .5, face = "plain",family     = "sans"),
        axis.text.y = element_text(color = "grey20", size = 10, angle = 0, hjust = 1, vjust = 0, face = "plain", family = "sans"),  
    axis.title.x = element_text(color = "grey20", size = 14, angle = 0, hjust = .5, vjust = 0, face = "plain", family
    = "sans"),
    axis.title.y = element_text(color = "grey20", size = 14, angle = 90, hjust = .5, vjust = .5, face = "plain", family = "sans"),
    legend.text = element_text(size = 10, hjust = .5, face = "plain",family = "sans"),
    legend.title = element_text(size = 14, face = "plain", family = "sans"),
    title = element_text(size = 14, face = "plain", family = "sans"))} #this makes a text theme that can be used in all graphs (don't have to type out every time)

#--- Good to inspect the data some before analyzing it.---
# table(complete.cases(canopy)) # All complete; no NAs
# table(complete.cases(overstory)) # 1 NA that's completely blank upon inspection; removed in code above when I read in the csv.
# table(complete.cases(regeneration[,c("year", "LocationID", "AcceptedSpecies", "Origin", 
#                                      "SumOfSeedling", "SumOfSmallSapling", "SumOfLargeSapling", 
#                                      "GrowthHabit")])) # No NAs. 
# summary(canopy)
# summary(overstory)
# summary(regeneration)
#
# table(overstory$AcceptedSpecies, useNA = "always")
# # table(regeneration$AcceptedSpecies, useNA = 'always') 
# plot(overstory$DBH)
# plot(regeneration$SumOfSeedling) # Year 2007; HOSPVegMon1; Frangula caroliniana has a high, but believable count.
# plot(regeneration$SumOfSmallSapling) # Year 2007; HOSPVegMon1; Frangula caroliniana has a high, but believable count.
# 
# plot(canopy$SumOfValue.1)
# plot(canopy$SumOfValue.2)
# plot(canopy$SumOfValue.3)
# plot(canopy$SumOfValue.4)
```

<!-- The line below should produce the same as the hard-coded title in the original rmd, but will update based on the params. Had to put this below the chunks above, because had to define First, and Current. But those could potentially be included in the YAML too. -->

# `paste0(parkcode, First, " - ", Current)` overstory, regen, canopy Analysis

# basal Area

##Live
<!-- This chunk runs ba- live analysis -->

```{r}
ba_site_class1 <- overstory1 |>
  filter(Condition == "L",
           SpeciesCode != "SNAG") |> #sort live and dead
  mutate(ba_ha = DBH^2*(0.00007854)/0.1#,
         #Year2 = as.character(Year2)
         )|> #calculate basal area per ha
  group_by(Year2, site, class)|>
  summarise(ba_site = sum(ba_ha), .groups = 'drop') #calculate ba per site by class

ba_site_class2 <- left_join(supplement, ba_site_class1, by = c('year' = 'Year2', 'site', 'class')) 
ba_site_class2$ba_site[is.na(ba_site_class2$ba_site)] <- 0

# Instead of assuming a normal distribution, I'm going to bootstrap the data to get a 
# sampling distribution of mean bas for each year x class combo

# Bootstrap function that will be used in purrr
boot_fun <- function(dat, col){
  dat1 <- dat[,col] # simplify dataframe into 1 column
  colnames(dat1) <- "col" # name column so easier to specify 
  samp <- dat1[sample(nrow(dat1), nrow(dat1), replace = T),] # sample the data once, returning same # rows with replacement
  mean <- mean(samp$col) # calculate mean of that sample
  return(data.frame(mean)) # return the mean as data.frame
}

# Iterate across year and class to get bootstrapped confidence intervals of ba
yxc_df <- unique(supplement[,c("year", "class")]) # need a dataframe with every comb. of Year and class
reps = 250 # Number of bootstrap samples

ba_year_class <- 
  purrr::map2(yxc_df$year, yxc_df$class, # iterate on each year x class combination 
              function(yr, cls){
                # create dataset for a given year x class combination
                dat <- ba_site_class2 |> filter(year == yr & class == cls)
                # create a data frame of bootstrapped means and bind list as rows in df
                dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "ba_site"), simplify = T)))
                # name the only column returned, so easier to specify below
                colnames(dat2) <- "samp_mean"
                # create a dataframe with mean of the raw data. 
                dat3 <- data.frame(ba_year_class = mean(dat$ba_site), # mean of raw data
                                   CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                   CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                   year = yr,
                                   class = cls, 
                                   num_boots = reps)
            }) |> list_rbind() # bind output as rows of dataframe, instead of list

write.csv(ba_year_class, 'Output Tables/basalArea_class.csv')

sxy_df <- unique(supplement[,c("year", "site")])

ba_year <-   purrr::map(year, # iterate on each year x class combination 
              function(yr){
                # create dataset for a given year x site combination
                dat <- ba_site_class2 |> filter(year == yr) |> group_by(site) |> summarize(ba_site = sum(ba_site))
                # create a data frame of bootstrapped means and bind list as rows in df
                dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "ba_site"), simplify = T)))
                # name the only column returned, so easier to specify below
                colnames(dat2) <- "samp_mean"
                # create a dataframe with mean of the raw data. 
                dat3 <- data.frame(ba_year = mean(dat$ba_site), # mean of raw data
                                   CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                   CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                   Year = yr, 
                                   num_boots = reps)
            }) |> list_rbind() # bind output as rows of dataframe, instead of list

write.csv(ba_year, 'Output Tables/basalArea.csv')

```

This chunk creates ba-live graphs

```{r}
yearba <- 
  ggplot(ba_year, aes(x = year, y = ba_year)) +
  geom_line(linewidth = 0.75, color = 'gray30') +
  geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = 0.5, linewidth = 0.75, color = 'gray30') +
  geom_point(size = 4, shape = 21, fill = '#437d69', color = 'gray30') + 
  ylim(0,max(ba_year$CI_high)) +
  labs(y = bquote('Mean basal Area ' ~ (m^2/ha)))+
  theme_veg() +
  theme_bw() +
  scale_x_continuous(limits = c(min(ba_year$year)-1, max(ba_year$year)+1), 
                     breaks = year)
yearba
ggsave('basalArea.jpg', dpi = 300, path = "Output Graphs") #saves basal area graph to Output Graphs

ba_by_class <- 
  ggplot(ba_year_class, aes(x = class, y = ba_year_class, fill = factor(year))) +
    geom_col(position = 'dodge') + 
    geom_errorbar(aes(ymin = CI_low, ymax = CI_high), 
                  position = position_dodge(0.9), width = 0.2, linewidth = 0.2) +
    scale_fill_grey() +
    labs(y = bquote('Mean basal Area ' ~ (m^2/ha)), fill = "Year") + 
    theme_veg() + theme_minimal()
  
ba_by_class
ggsave('basalArea_by_class.jpg', dpi = 300, path= "Output Graphs", height =5)#saves basal area by class graph to Output Graphs
```

## Dead

This chunk runs ba-dead analysis

```{r}
ba_site_class_D <- overstory1 |>
  filter(Condition == "D") |> #sort live and dead
  mutate(ba_ha = DBH^2*(0.00007854)/0.1) |> #,
         #Year2 = as.character(Year2))|> #dropped this b/c not needed
  group_by(Year2, site, class)|>
  summarise(ba_site = sum(ba_ha), .groups = 'drop') #calculate ba per site by class

ba_site_class_D2 <- left_join(supplement, ba_site_class_D, by = c('year' = 'Year2', 'site', 'class')) 
ba_site_class_D2$ba_site[is.na(ba_site_class_D2$ba_site)] <- 0

# Iterate across year and class to get bootstrapped confidence intervals of ba
yxc_df <- unique(supplement[,c("year", "class")]) # need a dataframe with every comb. of Year and class
reps = 250 # Number of bootstrap samples

ba_year_class_D <- 
  purrr::map2(yxc_df$year, yxc_df$class, # iterate on each year x class combination 
              function(yr, cls){
                # create dataset for a given year x class combination
                dat <- ba_site_class_D2 |> filter(year == yr & class == cls)
                # create a data frame of bootstrapped means and bind list as rows in df
                dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "ba_site"), simplify = T)))
                # name the only column returned, so easier to specify below
                colnames(dat2) <- "samp_mean"
                # create a dataframe with mean of the raw data. 
                dat3 <- data.frame(ba_year_class = mean(dat$ba_site), # mean of raw data
                                   CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                   CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                   year = yr,
                                   class = cls, 
                                   num_boots = reps)
              }) |> list_rbind() # bind output as rows of dataframe, instead of list

write.csv(ba_year_class_D, 'Output Tables/basalArea_class_D.csv')
ba_year_class_D

sxy_df <- unique(supplement[,c("year", "site")])

ba_year_D <-   purrr::map(year, # iterate on each year x class combination 
                        function(yr){
                          # create dataset for a given year x site combination
                          dat <- ba_site_class_D2 |> filter(year == yr) |> group_by(site) |> summarize(ba_site = sum(ba_site))
                          # create a data frame of bootstrapped means and bind list as rows in df
                          dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "ba_site"), simplify = T)))
                          # name the only column returned, so easier to specify below
                          colnames(dat2) <- "samp_mean"
                          # create a dataframe with mean of the raw data. 
                          dat3 <- data.frame(ba_year = mean(dat$ba_site), # mean of raw data
                                             CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                             CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                             year = yr, 
                                             num_boots = reps)
                        }) |> list_rbind() # bind output as rows of dataframe, instead of list

write.csv(ba_year_D, 'Output Tables/basalArea_D.csv')
ba_year_D
```

This chunk creates ba graphs for dead trees

```{r}
yearba_D <- 
  ggplot(ba_year_D, aes(x = year, y = ba_year)) +
  geom_line(linewidth = 0.75, color = 'gray30') +
  geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = 0.5, linewidth = 0.75, color = 'gray30') +
  geom_point(size = 4, shape = 21, fill = '#437d69', color = 'gray30') + 
  ylim(0,max(ba_year_D$CI_high)) +
  labs(y = bquote('Mean basal Area ' ~ (m^2/ha)))+
  theme_veg() +
  theme_bw() +
  scale_x_continuous(limits = c(min(ba_year_D$year)-1, max(ba_year_D$year)+1), 
                     breaks = year)
yearba_D
ggsave('basalArea_D.jpg', dpi = 300, path = "Output Graphs") #saves basal area graph to Output Graphs

ba_by_class_D <- 
  ggplot(ba_year_class_D, aes(x = class, y = ba_year_class, fill = factor(year))) +
    geom_col(position = 'dodge') + 
    geom_errorbar(aes(ymin = CI_low, ymax = CI_high), 
                  position = position_dodge(0.9), width = 0.2, linewidth = 0.2) +
    scale_fill_grey() +
    labs(y = bquote('Mean basal Area ' ~ (m^2/ha)), fill = "Year") + 
    theme_veg() + theme_minimal()
  
ba_by_class_D
ggsave('basalArea_by_class_D.jpg', dpi = 300, path= "Output Graphs", height =5)#saves basal area by class graph to Output Graphs
```

# density

## Live

This chunk runs the density analysis

```{r}
density <- overstory1 |>
  filter(Condition == 'L', SpeciesCode != "SNAG")|> #filters out dead trees and snags
  group_by(year = Year2, site, class)|> # note how you can rename things in a group_by. 
  summarise(count = n(), .groups = 'drop') #count number of stems in each density class for each year, site

density1 <- left_join(supplement, density, by = c("year", "site", "class"))
density1$count[is.na(density1$count)] <- 0
density1$areadensity = density1$count/0.1

# Iterate across year and class to get bootstrapped confidence intervals of ba
yxc_df <- unique(supplement[,c("year", "class")]) # need a dataframe with every comb. of Year and class
reps = 250 # Number of bootstrap samples

density_year_class <- 
  purrr::map2(yxc_df$year, yxc_df$class, # iterate on each year x class combination 
              function(yr, cls){
                # create dataset for a given year x class combination
                dat <- density1 |> filter(year == yr & class == cls)
                # create a data frame of bootstrapped means and bind list as rows in df
                dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "areadensity"), simplify = T)))
                # name the only column returned, so easier to specify below
                colnames(dat2) <- "samp_mean"
                # create a dataframe with mean of the raw data. 
                dat3 <- data.frame(dens_year_class = mean(dat$areadensity), # mean of raw data
                                   CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                   CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                   year = yr,
                                   class = cls, 
                                   num_boots = reps)
              }) |> list_rbind() # bind output as rows of dataframe, instead of list

write.csv(density_year_class, 'Output Tables/density_class.csv')
density_year_class

sxy_df <- unique(supplement[,c("year", "site")])

density_year <-   purrr::map(year, # iterate on each year x class combination 
                        function(yr){
                          # create dataset for a given year x site combination
                          dat <- density1 |> filter(year == yr) |> group_by(site) |> summarize(areadensity = sum(areadensity))
                          # create a data frame of bootstrapped means and bind list as rows in df
                          dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "areadensity"), simplify = T)))
                          # name the only column returned, so easier to specify below
                          colnames(dat2) <- "samp_mean"
                          # create a dataframe with mean of the raw data. 
                          dat3 <- data.frame(dens_year = mean(dat$areadensity), # mean of raw data
                                             CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                             CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                             year = yr, 
                                             num_boots = reps)
                        }) |> list_rbind() # bind output as rows of dataframe, instead of list

write.csv(density_year, 'Output Tables/density.csv')
density_year
```

This chunk makes density graphs

```{r}
year_density <-   
  ggplot(density_year, aes(x = year, y = dens_year)) +
    geom_line(linewidth = 0.75, color = 'gray30') +
    geom_errorbar(aes(x = year, ymin = CI_low, ymax = CI_high), width = 0.5, linewidth = 0.75, color = 'gray30') +
    geom_point(size = 4, shape = 21, fill = '#437d69', color = 'gray30') + 
    ylim(0, max(density_year$CI_high)) +
    ylab('Mean Stem density (stems/ha)')+ #labeling y axis
    theme_veg() +
    theme_bw() +
    scale_x_continuous(limits = c(min(density_year$year)-1, max(density_year$year)+1), 
                       breaks = year)
year_density
ggsave('density.jpg', dpi = 300, path = "Output Graphs")

class_density <- 
  ggplot(density_year_class, aes(x = class, y = dens_year_class, fill = factor(year))) +
    geom_col(position = 'dodge') + 
    geom_errorbar(aes(ymin = CI_low, ymax = CI_high), 
                  position = position_dodge(0.9), width = 0.2, linewidth = 0.2) +
    scale_fill_grey() +
    labs(y = 'Mean Stem density (stems/ha)', fill = "Year") + 
    theme_veg() + theme_minimal()

class_density
ggsave('density_class.jpg', dpi = 300, path = "Output Graphs")
```

## Dead

This chunk runs the density analysis for dead trees

```{r}
density_D <- overstory1 |>
  filter(Condition == 'D')|> #filters out dead trees and snags
  group_by(year = Year2, site, class)|> # note how you can rename things in a group_by. 
  summarise(count = sum(!is.na(DBH)), .groups = 'drop') #count number of stems in each density class for each year, site

density_D1 <- left_join(supplement, density_D, by = c("year", "site", "class"))
density_D1$count[is.na(density_D1$count)] <- 0
density_D1$areadensity = density_D1$count/0.1

# Iterate across year and class to get bootstrapped confidence intervals of ba
yxc_df <- unique(supplement[,c("year", "class")]) # need a dataframe with every comb. of Year and class
reps = 250 # Number of bootstrap samples

density_year_class_D <- 
  purrr::map2(yxc_df$year, yxc_df$class, # iterate on each year x class combination 
              function(yr, cls){
                # create dataset for a given year x class combination
                dat <- density_D1 |> filter(year == yr & class == cls)
                # create a data frame of bootstrapped means and bind list as rows in df
                dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "areadensity"), simplify = T)))
                # name the only column returned, so easier to specify below
                colnames(dat2) <- "samp_mean"
                # create a dataframe with mean of the raw data. 
                dat3 <- data.frame(dens_year_class = mean(dat$areadensity), # mean of raw data
                                   CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                   CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                   year = yr,
                                   class = cls, 
                                   num_boots = reps)
              }) |> list_rbind() # bind output as rows of dataframe, instead of list

write.csv(density_year_class_D, 'Output Tables/density_class_D.csv')
density_year_class_D

sxy_df <- unique(supplement[,c("year", "site")])

density_year_D <-   purrr::map(year, # iterate on each year x class combination 
                        function(yr){
                          # create dataset for a given year x site combination
                          dat <- density_D1 |> filter(year == yr) |> group_by(site) |> summarize(areadensity = sum(areadensity))
                          # create a data frame of bootstrapped means and bind list as rows in df
                          dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fun(dat, "areadensity"), simplify = T)))
                          # name the only column returned, so easier to specify below
                          colnames(dat2) <- "samp_mean"
                          # create a dataframe with mean of the raw data. 
                          dat3 <- data.frame(dens_year = mean(dat$areadensity), # mean of raw data
                                             CI_high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                             CI_low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                                             year = yr, 
                                             num_boots = reps)
                        }) |> list_rbind() # bind output as rows of dataframe, instead of list

write.csv(density_year_D, 'Output Tables/density_D.csv')
density_year_D
```

This chunk makes density graphs for dead trees

```{r}
year_density_D <-   
  ggplot(density_year_D, aes(x = year, y = dens_year)) +
    geom_line(linewidth = 0.75, color = 'gray30') +
    geom_errorbar(aes(ymin = CI_low, ymax = CI_high), width = 0.5, linewidth = 0.75, color = 'gray30') +
    geom_point(size = 4, shape = 21, fill = '#437d69', color = 'gray30') + 
    ylim(0, max(density_year_D$CI_high)) +
    ylab('Mean Stem density (stems/ha)')+ #labeling y axis
    theme_veg() +
    theme_bw() +
    scale_x_continuous(limits = c(min(density_year_D$year)-1, max(density_year_D$year)+1), 
                       breaks = year)
year_density_D
ggsave('density_D.jpg', dpi = 300, path = "Output Graphs")

class_density_D <- 
  ggplot(density_year_class_D, aes(x = class, y = dens_year_class, fill = factor(year))) +
  geom_col(position = 'dodge') + 
  geom_errorbar(aes(ymin = CI_low, ymax = CI_high), 
                position = position_dodge(0.9), width = 0.2, linewidth = 0.2) +
  scale_fill_grey() +
  labs(y = 'Mean Stem density (stems/ha)', fill = "Year") + 
  theme_veg() + theme_minimal()


class_density_D
ggsave('density_class_D.jpg', dpi = 300, path = "Output Graphs")
```

#Species-Wise Analysis

## Live

```{r}
## Calculating species change by ba
species_ba_site <- overstory1 |>
  filter(Condition == "L")|> #filter for only Live trees
  mutate(ba_ha = DBH^2*(0.00007854/0.1)) |> #convert DBH to ba scaled to hectare
  group_by(year = Year2, site, AcceptedSpecies)|>
  summarise(ba_site = sum(ba_ha, na.rm = T), .groups = 'drop')
  
species_ba <- species_ba_site |> 
  group_by(year, AcceptedSpecies)|> 
  summarise(meanba = sum(ba_site, na.rm = T)/nsites, 
            .groups = 'drop') #sumarise basal area mean across sites

species_ba_first <- species_ba |> filter(year == current)

pivotspecies_ba <- species_ba |> pivot_wider(names_from = year, values_from = meanba, values_fill = 0) |> 
  arrange(AcceptedSpecies) |> data.frame()

first_col <- which(grepl(current, names(pivotspecies_ba))) # Find column that matches current year
current_col <- which(grepl(first, names(pivotspecies_ba))) # Find column that matches first year

pivotspecies_ba$change <- pivotspecies_ba[,first_col] - pivotspecies_ba[,current_col] # Calc change

pivotspecies_ba$direction <- ifelse(pivotspecies_ba$change > 0, "Increase", "Decrease")

write.csv(pivotspecies_ba, "Output Tables/Species_ba.csv")
pivotspecies_ba  

## Calculating species change by density
species_density_site <- overstory1 |>
  filter(Condition == "L")|>
  group_by(year = Year2, site, AcceptedSpecies)|>
  summarise(stem_ha = sum(!is.na(DBH))/0.1, .groups = 'drop')#changed n()/0.1) to logical check that counts the #DBHs that aren't NA.

species_density <- species_density_site |>
  group_by(year, AcceptedSpecies)|>
  summarise(meandensity = sum(stem_ha)/nsites, .groups = 'drop') #calculates year mean density for each species

pivotspecies_density <- species_density |> pivot_wider(names_from = year, values_from = meandensity, values_fill = 0) |> 
  arrange(AcceptedSpecies) |> data.frame()

first_col <- which(grepl(current, names(pivotspecies_density))) # Find column that matches current year
current_col <- which(grepl(first, names(pivotspecies_density))) # Find column that matches first year

pivotspecies_density$change <- pivotspecies_density[,first_col] - pivotspecies_density[,current_col] # Calc. change

pivotspecies_density$direction <- ifelse(pivotspecies_density$change > 0, "Increase", "Decrease")

write.csv(pivotspecies_density, 'Output Tables/Species_density.csv')
pivotspecies_density
```

This chunk creates occurrence table

```{r}
pct_occ1 <- overstory1 |>
  filter(Year2 == current)|>
  group_by(site, AcceptedSpecies) |> 
  summarize(present = ifelse(sum(!is.na(DBH)) > 0, 1, 0), .groups = 'drop') |> 
  group_by(AcceptedSpecies)|>
  summarize(percentoccurence = sum(present)/nsites*100, .groups = 'drop')|>
  select(AcceptedSpecies, percentoccurence)

acc_spp <- data.frame(AcceptedSpecies = sort(unique(overstory1$AcceptedSpecies)))

pct_occ <- right_join(pct_occ1, acc_spp, by = "AcceptedSpecies") |> 
  mutate(percentoccurence = ifelse(is.na(percentoccurence), 0, percentoccurence)) |> 
  arrange(AcceptedSpecies)
  
write.csv(pct_occ, "Output Tables/PercentOccurence.csv", row.names = F)
```

This chunk creates change charts by species name

```{r}
## Subtraction change in ba
ggplot(pivotspecies_ba, 
       aes(y = reorder(AcceptedSpecies, desc(AcceptedSpecies)), 
           x = change, fill = factor(direction)))+ # sets ggplot to show species change in density
  geom_col(width = 0.4)+ #makes the ggplot a barplot
  theme_minimal()+ #background theme
  labs(y = 'Species Name', x = 'change in Mean basal Area', fill = "direction")+ #x axis label
  scale_fill_manual(breaks = c('Decrease', 'Increase'),
                    values = c('#FDB338', '#025196'))+ #manually setting color scale
  scale_x_continuous(breaks = scales::pretty_breaks(n=12))+
  theme_veg() +
  theme(axis.text.y = element_text(face = "italic"))+
  geom_vline(xintercept = 0)

ggsave('Species_ba_change_subtraction.jpg', dpi = 300, height = 8, width = 6, path = "Output Graphs")

## subtraction change in density
ggplot(pivotspecies_density, aes(y = reorder(AcceptedSpecies, desc(AcceptedSpecies)), 
                                 x = change, fill = direction))+ # sets ggplot to show species change in density
  geom_col(width = 0.4)+ #makes the ggplot a barplot
  theme_minimal()+ #background theme
  xlab('change in Mean Stem density (stems/ha)')+ #x axis label
  ylab('Species Name')+ #y axis label
  scale_fill_manual(breaks = c('Decrease', 'Increase'),
                    values = c('#FDB338', '#025196'))+ #manually setting color scale
  scale_x_continuous(breaks = scales::pretty_breaks(n=12))+
  theme_veg()+
  theme(axis.text.y = element_text(face = "italic"))+
  geom_vline(xintercept = 0)

ggsave('Species_density_change_subtraction.jpg', dpi = 300, height = 8, width = 6, path = "Output Graphs")
```

# canopy

This chunk of code makes table

```{r}
sum_cols <- c("SumOfValue.1", "SumOfValue.2", "SumOfValue.3", "SumOfValue.4")
canopy1 <- canopy
canopy1$site = as.character(gsub("[[:alpha:]]", "", canopy1$LocationID)) # Extract site number using base R
# table(canopy$SumOfValue.1 < 0) # There aren't any < 0, but will include step to convert -1 to NA in base R
# table(canopy$SumOfValue.2 < 0) # There aren't any < 0, but will include step to convert -1 to NA in base R
# table(canopy$SumOfValue.3 < 0) # There aren't any < 0, but will include step to convert -1 to NA in base R
# table(canopy$SumOfValue.4 < 0) # There aren't any < 0, but will include step to convert -1 to NA in base R
canopy1[, sum_cols][canopy1[,sum_cols] < 0] <- NA

canopy2 <- canopy1 |>
  mutate(C1 = SumOfValue.1 * 1.04, C2 = SumOfValue.2 * 1.04, C3 = SumOfValue.3 * 1.04, C4 = SumOfValue.4 * 1.04) |> #multiply by 1.04
  mutate(plotmean = (C1+C2+C3+C4)/4) |> data.frame()#|> #Calculate Plot mean (n=4)

# Bootstrap function that will be used in purrr
boot_fxn <- function(dat, col){
  dat1 <- data.frame(dat[,col]) # simplify dataframe into 1 column; not sure why I had to do this different than prev. boot_fun
  samp <- data.frame(dat1[sample(nrow(dat1), nrow(dat1), replace = T),]) # sample the data once, returning same # rows with replacement
  colnames(samp) <- "col" # name column so easier to specify 
  mean <- mean(samp$col) # calculate mean of that sample
  return(data.frame(mean)) # return the mean as data.frame
}

sxy_df2 <- canopy2 |> select(year = Year, site) |> unique()

canopy_site <- 
  purrr::map2(sxy_df2$site, sxy_df2$year, function(st, yr){
    dat <- canopy2 |> filter(site == st & Year == yr)
    dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fxn(dat, "plotmean"), simplify = T)))
    colnames(dat2) <- "samp_mean"
    dat3 <- data.frame(sitemean = mean(dat$plotmean), # mean of raw data
                       site95high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                       site95low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                       year = yr,
                       site = st,
                       num_boots = reps)
    }) |> list_rbind()

write.csv(canopy_site, 'Output Tables/canopyMean.csv')
canopy_site

canopy_year <- 
  purrr::map(year, function(yr){
                          dat <- canopy_site |> filter(year == yr) 
                          dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fxn(dat, "sitemean"), simplify = T)))
                          colnames(dat2) <- "samp_mean"
                          dat3 <- data.frame(yearmean = mean(dat$sitemean), # mean of raw data
                                             CI95high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                                             CI95low= quantile(dat2$samp_mean, probs = 0.025, names = F),
                                             year = yr, 
                                             num_boots = reps)
                        }) |> list_rbind() 


```

This chunk of code makes canopy graph

```{r}
mean_canopy <- 
  ggplot(canopy_year, aes(x = year, y = yearmean)) +
    geom_line(linewidth = 0.75, color = 'gray30') +
    geom_errorbar(aes(x = year, ymin = CI95low, ymax = CI95high), width = 0.5, linewidth = 0.75, color = 'gray30') +
    geom_point(size = 4, shape = 21, fill = '#437d69', color = 'gray30') + 
    ylim(0, max(canopy_year$CI95high)) +
    ylab('Mean canopy Cover (%)')+ #labeling y axis
    theme_veg() +
    theme_bw() +
    scale_x_continuous(limits = c(min(canopy_year$year)-1, max(canopy_year$year)+1), 
                       breaks = year)

mean_canopy
ggsave("Mean_canopy.jpg", dpi = 300, path = "Output Graphs", height = 4)


canopy_by_site<- 
  ggplot(canopy_site, aes(x = site, y =sitemean, fill=factor(year)))+ # makes ggplot of canopy with color indicating site
  geom_col(position = 'dodge')+
   scale_fill_grey()+
  labs(y = 'Mean canopy Cover (%)', fill = "Year")+
  theme_minimal()+
  geom_errorbar(aes(x = site, ymin = site95low, ymax=site95high), 
                position = position_dodge(0.9), width =0.2, linewidth =0.2)+
  theme_veg()
  
canopy_by_site
ggsave("canopy_by_site.jpg", dpi = 300, path = "Output Graphs", height = 4)
```

# regeneration

This chunk of code calculates regeneration density by class

```{r}
regeneration1 <- regeneration
names(regeneration1) <- gsub("SumOf", "", names(regeneration1)) # Drop SumOf from column names
regeneration1$site = as.character(gsub("[[:alpha:]]", "", regeneration1$LocationID)) # Extract site number using base R

type_regen1 <- 
  regeneration1 |> select(year = Year, site, AcceptedSpecies, Seedling, SmallSapling, LargeSapling) |>
  pivot_longer(cols = c(Seedling, SmallSapling, LargeSapling), names_to = "class", values_to = "count") |> 
  group_by(year, site, class) |> 
  summarize(sum1 = sum(count), 
            sum_ha = sum1/0.1,
            .groups = 'drop') 

yxc_df2 <- type_regen1 |> select(year, class) |> unique() |> data.frame()

type_regen <-
  purrr::map2(yxc_df2$year, yxc_df2$class, function(yr, cls){
    dat <- type_regen1 |> filter(year == yr & class == cls)
    dat2 <- data.frame(do.call(rbind, replicate(reps, boot_fxn(dat, "sum_ha"), simplify = T)))
    colnames(dat2) <- "samp_mean"
    dat3 <- data.frame(year = yr,
                       class = cls,
                       meandensity = mean(dat$sum_ha), # mean of raw data
                       low = quantile(dat2$samp_mean, probs = 0.025, names = F),
                       high = quantile(dat2$samp_mean, probs = 0.975, names = F), # upper 95% of bootstrapped means
                       num_boots = reps)
    }) |> list_rbind()

write.csv(type_regen, "Output Tables/regen_Meandensity_by_Type.csv")
type_regen

```

This chunk makes a graph of regeneration density by class

```{r}
type_regen$class <- factor(type_regen$class, levels = c("Seedling", "SmallSapling", "LargeSapling"))

type_regen_graph <-
  ggplot(type_regen |> arrange(meandensity), aes(x = class, y = meandensity, fill = factor(year)))+
  geom_col(position = "dodge")+ #sets bars next to each other
  geom_errorbar(aes(x = class, ymin = low, ymax= high), width = 0.2, position = position_dodge(0.9), linewidth = 0.2)+ #add error bar
  theme_minimal()+
  labs(y = 'Mean density (stems/ha)', fill = "Year")+
  scale_fill_grey()+
  theme_veg()

type_regen_graph
ggsave('regeneratoin_Type.jpg', path = "Output Graphs", dpi= 300)
  
```

regen by species analysis code

```{r}
#this creates the dataframe used to generate graphs

regen_species1 <- regeneration1 |>
  select(year = Year, site, AcceptedSpecies, Seedling, SmallSapling, LargeSapling) |>
  pivot_longer(cols = c(Seedling, SmallSapling, LargeSapling), names_to = "class", values_to = "count")|> #making each class its own row
  mutate(density_ha = count/0.1)|> # convert to stems/ha
  select(!count)|>
  group_by(year, AcceptedSpecies, class)|> #sort by species each year
  summarise(year_density = (sum(density_ha))/nsites, 
            .groups = 'drop') #summarise the year mean density class

regen_species_curr <- regen_species1 |> filter(year == current)
regen_species_first <- regen_species1 |> filter(year == first)

regen_species <- full_join(regen_species_curr |> select(-year), 
                          regen_species_first |> select(-year), 
                          by = c("AcceptedSpecies", "class"),
                          suffix = c("_curr", "_first")) |> 
  mutate(year_density_curr = ifelse(is.na(year_density_curr), 0, year_density_curr),
         year_density_first = ifelse(is.na(year_density_first), 0, year_density_first),
         change = year_density_curr - year_density_first,
         direction = case_when(change > 0 ~ "Increase", 
                               change < 0 ~ "Decrease", 
                               change == 0 ~ "No change")) |> 
  arrange(AcceptedSpecies)

#table(regenSpecies_comb$AcceptedSpecies, regenSpecies_comb$class) # make sure every species/class is represented only once

#this creates the wider dataframe to export
class_changes <- regen_species |>
  select(!direction)|>
  pivot_wider(names_from = class, values_from = change)|>
  rename(change_seedling = Seedling,
         change_smallsapling = SmallSapling,
         change_largesapling = LargeSapling)

# base R convert NA to 0 for multiple columns
change_cols <- c("change_largesapling", "change_seedling", "change_smallsapling")
class_changes[,change_cols][is.na(class_changes[,change_cols])] <- 0

# Set order of factor levels for class
regen_species1$class <- factor(regen_species1$class, levels = c("Seedling", "SmallSapling", "LargeSapling"))

regen_species_table <- regen_species1 |>
  arrange(class) |> 
  pivot_wider(names_from = c(class, year), values_from = year_density)|>
  arrange(AcceptedSpecies)|>
  left_join(class_changes, by = "AcceptedSpecies")
  
write.csv(regen_species_table, "Output Tables/regen_byType_Species.csv", row.names = F)

regen_species_table
  
```

This chunk makes change graphs for regeneration by species, each class is graphed alone

```{r}

## Seedling
seedling <-
  ggplot(regen_species |> filter(class == "Seedling"), 
         aes(y = reorder(AcceptedSpecies, desc(AcceptedSpecies)), 
             x = change, fill = direction))+ #ggplot y axis barplot with colors based on increase or decrease
  geom_col(width = 0.4)+ #width of columns
  theme_minimal()+
  xlab('change in Mean density (Stems/ha)')+
  ylab('Species Name')+
  labs(title = 'Seedlings', fill = "Direction")+
  scale_fill_manual(breaks = c('Decrease','Increase'),
                    values = c('#FDB338', '#025196'))+ #sets color for increase/decrease
  scale_x_continuous(breaks = scales::pretty_breaks(n=15))+ #changes number of ticks on x axis
  theme_veg()+
  theme(axis.text.y = element_text(face = "italic"), #makes species names italic
        axis.text.x = element_text(angle = 90))+
  geom_vline(xintercept = 0)
seedling
ggsave('regeneration_Species_Seedling_subtraction.jpg', path = "Output Graphs", dpi= 300, height = 6)
  
## Small Sapling
smallsapling <- 
  ggplot(regen_species |> filter(class == "SmallSapling"), 
         aes(y = reorder(AcceptedSpecies, desc(AcceptedSpecies)), 
             x = change, fill = direction))+#ggplot y axis barplot with colors based on increase or decrease
  geom_col(width = 0.4)+#width of columns
  theme_minimal()+
  xlab('change in Mean density (Stems/ha)')+
  ylab('Species Name')+
  labs(title = 'Small Saplings', fill = "Direction")+
  scale_fill_manual(breaks = c('Decrease','Increase', 'No change'),
                    values = c('#FDB338', '#025196', 'dimgrey'))+#sets color for increase/decrease
  scale_x_continuous(breaks = scales::pretty_breaks(n=15))+#changes number of ticks on x axis
  theme_veg()+
  theme(axis.text.y = element_text(face = "italic"),#makes species names italic
        axis.text.x = element_text(angle = 90))+
  geom_vline(xintercept = 0)
smallsapling
ggsave('regeneration_Species_SmallSap_subtraction.jpg', path = "Output Graphs", dpi= 300, height = 6)

## Large Sapling
largesapling <- 
  ggplot(regen_species |> filter(class == 'LargeSapling'), #filter for large saplings
         aes(y = reorder(AcceptedSpecies, desc(AcceptedSpecies)), 
             x = change, fill = direction)) + #ggplot y axis barplot with colors based on increase or decrease
  geom_col(width = 0.4)+ #width of columns
  theme_minimal()+
  xlab('change in Mean density (Stems/ha)')+
  ylab('Species Name')+
  labs(title = 'Large Saplings', fill = "Direction")+
  scale_fill_manual(breaks = c(breaks = c('Decrease','Increase', 'No change')),
                    values = c('#FDB338', '#025196', 'dimgrey'))+#sets color for increase/decrease
  theme_veg()+
  theme(axis.text.y = element_text(face = "italic"))+#makes species names italic
  geom_vline(xintercept = 0)
ggsave('regeneration_Species_LargeSap_subtraction.jpg', path = "Output Graphs", dpi= 300, height = 6)

```
